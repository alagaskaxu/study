#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
//#include <stdlib.h>

//操作符详解

/*
* 分类:
* 算术操作符,位移操作符,位操作符,赋值操作符,单目操作符,
* 关系操作符,逻辑操作符,条件操作符,
* 逗号表达式
* 下标引用,函数调用和结构成员
*/

// 算术操作符: + - * / %
// 移位操作符: 左移>> 右移<<
// 位操作符: 按位与&, 按位或|, 按位异或^
// 赋值操作符:	直接赋值 =  符合赋值符: += -= *= /= %=  >>= <<=  &= |= ^= 
// 单目操作符(只有一个操作数):	! 逻辑反操作, - 负值, + 正值, & 取地址, sizeof 求操作数的类型长度(以字节为单位), ~对一个数的二进制位按位取反, ++ 前置/后置++, --前置/后置--, *间接访问操作符(解引用操作), (类型) 强制类型转换如(int)
// 关系操作符: 大于>  大于等于>=  小于<  小于等于<=  不相等 !=  相等 ==
// 逻辑操作符: 逻辑与 &&  逻辑或 ||
// 条件操作符(三目操作符): exp0? exp1:exp2
// 逗号表达式:(exp1,exp2,exp3,....,expN)
// 下标引用,函数调用和结构成员: []  ()  . ->

int add(int x, int y);//函数声明,具体实现在最下面
struct book	//定义一个自定义的类型
{
	char name[20];	//书名
	char id[20];	//id
	int price;		//价格
	int page;		//页数
};	//结构体声明
int main()
{
	//算术操作符
	float a = 6 / 5;//1.000000,/除法是整数除法,商1
	printf("%f\n", a);	//%f单精度float格式
	double b = 6.0 / 5;//1.200000,/除法有一个数有小数点就能计数出小数,得出的结果为双精度double类型,用float单精度可以存,会损失精度
	//float b = 6.0f / 5;//1.200000,6.0后加f表示为单精度float,得出结果也为float类型
	printf("%lf\n", b);//%lf双精度格式
	int c = 7 % 3;//余1	%取模,取余,两个操作数必须为整形
	printf("%d\n", c);//1

	//移位操作符	将二进制位移动,一共32位或64位	<<左移:左边(最高位)丢弃(移入CF标志位),右边(最低位)补零	>>右移:算术右移(有符号数原最高位的符号位数值保留同时向右移,最左边补原来的符号位,最低位丢弃),逻辑右移(左边补零,最高位右移,最右边(最低位)丢弃移入CF标志位)
	c = 2;	//0010
	int d = c << 1;	//0100
	printf("%d\n", d);	//4

	c = -10;	//原码:10001010 ;负数在实际内存中是存放补码 11110110,算术右移一位补码:11111011
	//当前编译器为算术右移:原最高位右移,符号位保留(即原来是负(1),新的最高位符号位仍为负),最低位丢弃,存入CF标志位
	d = c >> 1;	//原码:10000101 ;补码11111011
	printf("d = %d\n", d);	// -5
	printf("c = %d\n", c);	// -10 ;移位操作不影响原来变量的数值

	//位操作:按二进制位与^,按位或|,按位异或^ ; 操作数必须为整形
	c = 3;	//0000 0011
	d = 5;	//0000 0101
	int e = c & d;	//&按位与:对应位置与操作;与:有0则为0. 1&1=1;1&0=0;0&0=0;0&1=0
			//0000 0001
	printf("& e = %d\n", e);	// 1
	// | 按位或,对应位置或操作; 或: 有1则为1. 0 | 0 = 0,1 & * =1;
	e = c | d;
			//0000 0111 == 7
	printf("| e = %d\n", e); // 7
	// ^ 按位异或;异或: 相同则为0,不同则为1. 1^1=0,0^0=0;1^0=1,0^1=1
	e = c ^ d;
			//0000 0110 == 6
	printf("^ e = %d\n", e); // 6

	//不用变量,交换两个整形
	c = 3, d = 5;	//c 011 d 101  c^d = 011 ^ 101 == 110
	c = c ^ d;	//c = 011 ^ 101 == 110
	d = c ^ d;	//d = 110 ^ 101 == 011
	c = c ^ d;	//c = 110 ^ 011 == 101
	printf("c = %d\n", c);
	printf("d = %d\n", d);

	//求一个整数存储在内存中的二进制位为1的个数
	c = 10;		//补码00000000 00000000 00000000 00001010
	int count = 0;
	while (c)
	{
		d = c & 1;
		c = c >> 1;
		if (1 == d)
		{
			count++;
		}
	}
	printf("10 count = %d\n", count);

	c = 13; //00001101
	//第五位 置为1
			//00010000
	d = 1 << 4;//1左移四位
	c = c | d;	//按位或
	printf("第五位置1后 c = %d\n", c);	//29
	//第五位置再置0
	d = ~d;	//按位取反
		// d = 111011111
	c = c & d;
	printf("第五位置0后 c = %d\n", c);	//13

	//赋值操作符: = += ...,可以给变量重新赋值
	int x = 0;
	int y = 20;
	c = x = y + 1;	//连续赋值,从右到左
	//一般不会写连续赋值,分开写
	printf("c= %d\nx= %d\n", c, x);
	c = 100;
	c += 100;	//c= c+ 100;等价
	printf("c= %d\n", c);

	//单目操作符:只有一个操作数
	// ! 逻辑反操作, ~对一个数的二进制位按位取反, ++ 前置/后置++, --前置/后置--,  (类型) 强制类型转换如(int)
	int flag = 0;
	if (flag)	//flag为真时
	{
		printf("flag为真,%d\n", flag);
	}
	if (!flag)	//!flag表示flag为假时
	{
		printf("flag为假,!flag= %d,flag =%d\n", !flag, flag);
	}
	// -负值, +正值
	x = 10;
	x = -x;	//x = -10
	y = +x;	//y = -10,+一般都省略
	printf("x= %d\ny= %d\n", x, y);
	//sizeof 计数操作数类型的长度(以字节为单位)
	x = 10;
	char ch[10] = { 0 };
	printf("x = %d字节\n", sizeof(x));
	printf("x = %d字节\n", sizeof x);	//计算变量名,()可以省略,说明是操作符,不是函数
	printf("int= %d字节\n", sizeof(int));	//计算类型,不能省略()
	printf("ch[10] = %d字节\n", sizeof(ch));	//一个字符1字节,10个就是10字节
	printf("int [10] = %d字节\n", sizeof(int [10]));	//一个int类型4字节,10个就是40字节
	short s = 5;	//short类型 2字节
	x = 10;//int类型
	printf("sizeof s = %d\n", sizeof(s));	//2
	printf("sizeof s=x+2 = %d\n", sizeof(s = x + 2));	//2,sizeof内的表达式不进行运算,只计数了s的类型大小
	printf("sizeof s = %d\n", sizeof(s));	//2
	printf("s = %d\n", s);	//s = 5,sizeof内的表达式不进行运算
	// ~ 对一个数的二进制数按位取反
	x = -1;//原码:100000000 00000000 00000000 00000001
	printf("x = %d\n", x);
//内存中存放的是补码:11111111 11111111 11111111 11111111
	x = ~x;//按位取反(包括符号位)补码:000000 .. 00000000,正数原码补码一样 , x = 0
	printf("~x = %d\n", x);

	//前置/后置++与--
	int i = 0;
	int j = 0;
	//后置++,简单理解:先赋值,再++
	j = i++;	//j = i = 0
	printf("i = %d\n", i);	//i=i+1 = 1
	printf("j = %d\n", j);	//j = 0
	i = 0;
	j = 0;
	//前置++,简单理解:先++,再赋值
	j = ++i;	//j = i = i + 1
	printf("i = %d\n", i);	//i=i+1 = 1
	printf("j = %d\n", j);	//j = i = 1
	i = 0;
	j = 0;
	//后前置--,简单理解:先赋值,再--
	j = i--;	//j = i = 0
	printf("i = %d\n", i);	//i=i-1 = -1
	printf("j = %d\n", j);	//j = 0
	x = 10;
	printf("x= 10,x-- = %d\n", x--);	//x=10打印,然后x=x-1=9
	printf("x = %d\n", x);	//x = 9

	//&取地址, *间接访问操作符(解引用)
	x = 10;
	//&取地址操作符
	printf("&x = %p\n", &x);	//%p按地址格式打印
	int* pa = &x;	//pa用来存放地址, pa就是一个指针变量
	//pa指针指向x,存放的是x的地址
	//通过*解引用操作符来操作pa指向的对象
	*pa = 20;	//就是将20赋值给了x
	printf("x = %d\n", x);

	//(类型) 强制类型转换
	a = 3.14;	//a是float类型
	x = (int)a;	//x是int类型,a强制转换为int类型
	printf("x = %d\n", x);//3,小数强制去除

	//关系操作符: 大于>  大于等于>=  小于<  小于等于<=  不相等 !=  相等 ==
	x = 3;
	y = 5;
	if (x < y)
	{
		printf("bigger = %d\n", y);
	}
	else if (x == y)
	{
		printf("equal\n");
	}
	//== 为判断相等,一个=为赋值
	// ==一般用来判断两个数字是否相等,不是所有的判断相等都用 == 如 ==不能判断字符串相等

	//逻辑操作符:逻辑与 &&  逻辑或 ||
	//逻辑与(且),有假则为假,全真才为真
	//逻辑或,有真则为真,全假才为假
	x = 3;	//不为0则是真
	y = 0;	//0为假
	if (x || y)	//x或y有一个为真则为真
	{
		printf("x||y = %d\n", x || y);	//1
	}
	printf("x&&y = %d\n", x && y);	// 0  x和y都为真,x&&y才为真

	i = 0, x = 0, y = 2, c = 3, d = 4;
	i = x++ && ++y && d++;	//x为0, 0 && ++y,不会继续运算后面的表达式,直接i = 0,最后只运算了 x++ && 这个表达式
	//i = x++ || ++y || d++;	//1 3 3 4 ,同理,遇到真后||后面的表达式就不关了
	printf("a= %d, b= %d, c= %d, d= %d\n", x, y, c, d);	// 1 2 3 4

	//条件操作符(三目操作符):exp0? exp1:exp2

	x = 3;
	y = 0;
	/*
	if (x>5)
	{
		y = -1;
	}
	else
	{
		y = 1;
	}
	*/

	y = x > 5000. ? -1 : 1;//x>5为真则y=-1不然y=1,哪个表达式满足要求才开始计算那一个表达式,其它不进行运算
	printf("y = %d\n", y);

	// 逗号表达式:(exp1,exp2,exp3,....,expN)	表达式从左向右依次运算,整个表达式的结果为最后一个表达式的值
	x = 3, y = 5, c = 0;
	d = (c = 5, x = c + 3, y =x + 4);	//d为最后一个表达式的值,如果最后一个表达式为y = 4,则 d = y = 4
	printf("d = %d,x = %d\n", d,x);

	//下标引用, 函数调用和结构成员
	//[]下标引用操作符
	int ar[10] = { 0,1,2,3,4,5,6,7,8,9 };	//数组ar的下标从0开始到9
	printf("ar[4] = %d\n", ar[4]);	//下标引用操作符[]
	//[]的两个操作数分别是arr和4

	//函数调用操作符
	x = 10;
	y = 20;	//add的具体实现在最后
	int ret = add(x, y);	//函数调用操作符(),()不能省略,()就是调用操作符
	//add()有三个操作数,函数名add,参数x,参数y.	函数调用的操作数至少有一个函数名,可以根据函数实现原理没有参数
	printf("ret = %d\n", ret);

	//结构成员操作符
	// . 结构体.成员名
	//-> 结构体指针->成员名
	struct book b0;		//创建结构体
	struct book b1 = { "c语言", "c123456", 55, 99 };		//创建结构体并初始化
	//结构体.成员名
	printf("书名: %s 书号: %s\n", b1.name, b1.id);
	//结构体book类型的指针指向b1
	struct book* pb = &b1;
	//结构体->成员名		与*解引用,(*pb)就是b1
	printf("价格: %d 页数: %d\n", pb->price, (*pb).page);

	return 0;
}

int add(int x, int y)	//函数实现
{
	return x + y;
}

