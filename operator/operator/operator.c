#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main()
{
	//操作符operator		操作数:操作符旁的操作实体(数据),a = 9则a和9都是操作数
	//算术操作符:+ - *乘 /除 %取余(取模)
	//移位操作符: >>右移操作符  <<左移操作符 移动二进制位

	float a = 9 / 2;//整形除整形只能得到整形,结果为4.000000
	float b = 9.0 / 2;//有一个数为浮点型就进行浮点运算,结果为4.500000
	printf("9/2=%f\n9.0/2=%f\n", a, b);
	int c = 9 % 2;//取模(余)9/2=4...1,结果为1
	printf("9%%2=%d\n", c);//%%可以打出一个%
	c = 2;
	c = c << 1;
	printf("2<<1=%d\n", c);//<<1 向左移动一个二进制位  0010 -> 0100

	//位操作符:&按位与(且,全1为1,有0为0)  |按位或(或,有1为1,全0为0)  ^按位异或(相同为0,相异为1)  ~按位取反(0变1,1变0),机器以补码存数据
			//只有~是单目操作符(只有一个操作数如~c),&|^ << >>为双目(两个操作数c<<1),位操作符只能用于整形数据

	//赋值操作符: = 可以复合:+= -+ *= /= &= |= ^= >>= <<= (因为~是单目操作，所以，没有~=)
				//a+=b; ==> a=a+b; 左操作数加右操作数赋值给左操作数
	int x = 2,y=7;
	x += 5;//x=x+5,x=7
	x *= 2;//x=x*2,x=14	01110
	x &= y;//14与7(00111)进行二进制的按位与,x=6(00110)
	printf("x=%d\n",x);
	printf("x=%d\n",~y);//按位取反,00000111(7的补码)->11111000(~7的补码)->11110111(~7的反码)->10001000(~7的原码=-8)
						//计算机用补码存数据,第一位为符号位1为负数0为正
						//正数的反码补码等于源码,负数的反码等于原码取反但符号位不变仍为1,负数补码为反码+1
						//补码的补码等于原码,~7求补直接可得原码11111000(补码)->10000111(补码的反码)  +1 ->10001000(补码的补码 =-8)

	//单目操作符:只有一个操作数 ! - + & sizeof ~ -- ++ * (类型)
	// ! 逻辑反操作,非(非0为真,1为真0为假,!0=1), - 负值(a=-5,a=-a;), + 正值, & 取地址符(&a), sizeof 操作数类型的长度(以字节为单位)
	// ~ 二进制按位取反, 前/后置--(i--,--i), 前/后置++(i++,++i)
	/* 
		* 间接访问操作符(接引用操作符)
		引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。
		引用的声明方法：类型标识符& 引用名 = 目标变量名；int a; int& ra = a; 
		定义引用ra,它是变量a的引用，即别名,&在此处不表示取地址符,仅起标识作用
	*/
	//(类型) 强制类型转换
	
	//两个操作数则叫双目操作符
	int t = 10,f = 0;//x=10,x不等于0(不为假),则x为真;f=0,f为假
	printf("!t真假? %d ; !f真假? %d\n", !t,!f);//!x为非真则结果为假,输出0;!f为非假则为真1
	printf("int大小=%d Byte\n", sizeof(int));//求类型大小()不能省略,求变量的类型大小可以省略
	printf("操作数t的类型的大小=%d Byte\n", sizeof t);//求变量t的类型大小 sizeof 后的括号可以省略,因为是操作符不是函数
	int ar[10] = { 0 };//10个int元素,每个元素4B,一共40B
	printf("ar数组的大小=%d Byte\n", sizeof(ar));//结果为40B



	return 0;
}