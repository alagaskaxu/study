#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main()
{
	//操作符operator		操作数:操作符旁的操作实体(数据),a = 9则a和9都是操作数
	//算术操作符:+ - *乘 /除 %取余(取模)
	//移位操作符: >>右移操作符  <<左移操作符 移动二进制位

	float a = 9 / 2;//整形除整形只能得到整形,结果为4.000000
	float b = 9.0 / 2;//有一个数为浮点型就进行浮点运算,结果为4.500000
	printf("9/2=%f\n9.0/2=%f\n", a, b);
	int c = 9 % 2;//取模(余)9/2=4...1,结果为1
	printf("9%%2=%d\n", c);//%%可以打出一个%
	c = 2;
	c = c << 1;
	printf("2<<1=%d\n", c);//<<1 向左移动一个二进制位  0010 -> 0100

	//位操作符:&按位与(且,全1为1,有0为0)  |按位或(或,有1为1,全0为0)  ^按位异或(相同为0,相异为1)  ~按位取反(0变1,1变0),机器以补码存数据
			//只有~是单目操作符(只有一个操作数如~c),&|^ << >>为双目(两个操作数c<<1),位操作符只能用于整形数据

	//赋值操作符: = 可以复合:+= -+ *= /= &= |= ^= >>= <<= (因为~是单目操作，所以，没有~=)
				//a+=b; ==> a=a+b; 左操作数加右操作数赋值给左操作数
	int x = 2,y=7;
	x += 5;//x=x+5,x=7
	x *= 2;//x=x*2,x=14	01110
	x &= y;//14与7(00111)进行二进制的按位与,x=6(00110)
	printf("x=%d\n",x);
	printf("x=%d\n",~y);//按位取反,00000111(7的补码)->11111000(~7的补码)->11110111(~7的反码)->10001000(~7的原码=-8)
						//计算机用补码存数据,第一位为符号位1为负数0为正
						//正数的反码补码等于源码,负数的反码等于原码取反但符号位(最高位)不变仍为1,负数补码为反码+1
						//补码的补码等于原码,~7求补直接可得原码11111000(补码)->10000111(补码的反码)  +1 ->10001000(补码的补码 =-8)

	//单目操作符:只有一个操作数 ! - + & sizeof ~ -- ++ * (类型)
	// ! 逻辑反操作,非(非0为真,1为真0为假,!0=1), - 负值(a=-5,a=-a;), + 正值, & 取地址符(&a), sizeof 操作数类型的长度(以字节为单位)
	// ~ 二进制按位取反, 前/后置--(i--,--i), 前/后置++(i++,++i)
	/* 
		* 间接访问操作符(接引用操作符)
		引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。
		引用的声明方法：类型标识符& 引用名 = 目标变量名；int a; int& ra = a; 
		定义引用ra,它是变量a的引用，即别名,&在此处不表示取地址符,仅起标识作用
	*/
	//(类型) 强制类型转换 如(int) 3.14
	
	//两个操作数则叫双目操作符
	int t = 10,f = 0;//x=10,x不等于0(不为假),则x为真;f=0,f为假
	printf("!t真假? %d ; !f真假? %d\n", !t,!f);//!x为非真则结果为假,输出0;!f为非假则为真1
	printf("int大小=%d Byte\n", sizeof(int));//求类型大小()不能省略,求变量的类型大小可以省略
	printf("操作数t的类型的大小=%d Byte\n", sizeof t);//求变量t的类型大小 sizeof 后的括号可以省略,因为是操作符不是函数
	int ar[10] = { 0 };//10个int元素,每个元素4B,一共40B
	printf("ar数组的大小=%d Byte\n", sizeof(ar));//结果为40B

	//前置++: i++与后置++: ++i(i--和i++原理一样)
	int i=1, j=0;
	j = i++;//类似j=i,i=i+1; 实际上i++:i先自增,再返回自增前的值,最后i+1了,但返回的值却是i+1前的数字(具体原因涉及堆栈问题)
	printf("j=i++,i=1得j=%d ,i=%d\n", j, i);//j=1,i=2
	j = 0, i = 1;
	j = ++i;//类似i=i+1,j=i; ++i:i先自增再返回自增后的值
	printf("j=++i,i=1得j=%d ,i=%d\n", j, i);//j=2,i=2

	//(类型) 强制类型转换
	int p = (int)3.14;//强制转换会丢失精度
	printf("p(3.14)=%d\n", p);//输出p=3

	//关系操作符:  >大于 >=大于等于 <小于 <=小于等于 !=不等于 ==等于

	//逻辑操作符:  &&逻辑与(并且)  ||逻辑或(或者)
	x = 3, y = 5;//x不为0则为真1,y为真1
	int z = x && y;//x且y,真且真,1&1=1
	printf("x(真)且y(真)则真假?%d\n", z);
	x = 0, y = 5;//x为假,y为真
	z = x && y;//且:有假则假
	printf("x(假)且y(真)则真假?%d\n", z);//结果为假0

	//条件操作符(三目操作符)(exp值表达式):  exp1 ?  exp2 : exp3 
	//exp1成立吗?  成立,则结果为exp2的结果 ; exp1成立吗?  不成立,那么结果为exp3的结果
	int num1 = 1, num2 = 3, max = 0;
	num1 > num2 ? printf("max=%d\n", num1) : printf("max=%d\n", num2);//求两数最大值
	max = num1 > num2 ? num1 : num2;
	printf("max1=%d\n", max);//max1=3
	num1 > num2 ? max = num1 :num2;//不可为max = num1 :max = num2
	printf("max2=%d\n", max);//max2=3

	//逗号表达式:  exp1,exp2,exp3,...,expN  (逗号隔开的一串表达式)
	//逗号表达式,从左向右依次计算,整个表达式最后结果为最后一个表达式的结果
	x = 0;
	y = 3;
	z = 5;
	num1 = (x = y + 2, z = x - 4, y = z + 2);
	//x=3+2=5,z=5-4=1,y=1+2=3
	printf("逗号表达式=%d\n", num1);

	//下标引用操作符[],函数调用操作符(),结构成员操作符 . -> (结构体.成员名   结构体指针->成员名;在结构体详解)
	int arr[5] = {0,1,2,3,4};
	printf("arr[2]=%d\n", arr[2]);//[]下表引用, ()函数调用

	return 0;
}