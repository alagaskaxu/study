#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>


//指针初阶与进阶
//指针:编程语言中的一个对象,利用地址,它的值指向存在电脑存储器中另一地方的值.地址指向所需的变量单元
//一个内存单元占一字节对应一个地址编号
//int* pa; 用来存放地址的变量叫指针变量,pa为int型的指针变量
//指针变量在32位平台占4字节(32bit),在64位平台占8字节(64bit)
int my_strlen(char* str);
int my_strlen2(char* str);
int main()
{
	int a = 10;	//内存中占4字节
	int* pa = &a;	//取a的首地址存入pa指针,用来存放地址的变量叫指针变量
	*pa = 20;	//将指针pa指向的变量赋值为20

	//指针和指针类型
	char* pc;	//char类型的指针
	float* pf;	//float类型的指针
	printf("指针大小 %d\n", sizeof(pa));	//4
	printf("指针大小 %d\n", sizeof(pc));	//4
	printf("指针大小 %d\n", sizeof(pf));	//4

	//指针类型的意义
	a = 0x11223344;	//32位平台,16进制最大为0xffffffff,一个f为15占4bit(1111)
	pc = &a;	//char* pc;
	*pc = 0;	//char类型指针虽然占4字节,但是char类型原本为1字节的类型
	printf("char类型指针改int a=%x\n", a);	//11223300 ,char类型一字节,而int类型 44占一字节被char类型的指针改为00
	int arr[10] = { 0 };	//数组名为首元素地址
	int* p = arr;	//数组名就是首元素地址就是指针
	pc = arr;
	printf("p的地址为 %p\n", p);	//p和pc的地址一样
	printf("p+1的地址为 %p\n", p + 1);	//p+1的实际地址为p的地址+4(int类型的+1下一个地址要跳过一个int类型(4字节)即4个地址编号)
	printf("pc的地址为 %p\n", pc);
	printf("pc+1的地址为 %p\n", pc + 1);	//pc+1的地址为pc+1(char类型的+1下一个地址要跳过1个char类型(1字节)即1个地址编号)

	/*
		1.指针类型决定了:指针解引用时的权限有多大(简单理解:指针存放首元素地址,指针类型决定了从首地址开始一共可以访问几个地址,再结束)
		2.指针类型决定了:指针+1的步长(指针向前或向后走一步,能走多长字节),如int类型的指针+1一步就是4字节,char类型的指针一步为1字节,double类型的指针走一步就+8字节
	*/

	//指针的解引用: *pa ,表示pa指针对应的那个元素,解引用可以通过*pa来改变对应变量的值

	//野指针:野指针就是指针指向的位置是不可知的(随机的,不正确的,没有明确限制的)
	//野指针一般会导致程序崩溃
	/*
	* 野指针的成因:
	* 1.指针未初始化
	* 2.指针越界访问
	* 3.指针指向的空间被释放了
	*/
	//1.指针未初始化导致野指针
	// int* pb;	//pb是一个局部的指针变量,局部变量不初始化的话,默认是随机值
	// *pb = 20;	//pb指向的就是随机的地址,pb是野指针,*pb不可确定非法访问内存了

	//2.指针越界导致野指针
	/*
	p = arr;
	int i = 0;
	for ( i = 0; i <= 10; i++)	//p多加一次,一共加了11次,最后一次p指针越界,超过arr的大小了,最后变成野指针
	{
		*p = i;
		p++;
	}
	*/

	//3.指针指向的空间被释放了
	//详细看动态内存的知识

	/*
	* 如何规避野指针
	* 1.指针初始化
	* 2.小心指针越界
	* 3.指针指向空间被释放时 将指针置为NULL空指针, p = NULL;
	* 4.指针使用之前检查有效性(指针是否为空,是否为野指针)
	*/
	//当前不知道指针应该初始化为什么地址时,直接初始化为NULL空指针
	int* pb = NULL;

	//指针运算
	//指针+-整数
	//如上面的p+1,pc+1,p++

	//指针-指针:得到两个指针之间的元素个数
	//!!指针相减的前提是:两个指针指向同一空间,如:同一个数组
	p = &arr[0];
	pb = &arr[9];
	printf("&arr[9] - &arr[0] = %d\n", pb - p);	//9,两个指针之间一9个元素

	//指针的关系运算
	float values[5];
	float* vp;
	for ( vp = &values[0]; vp < &values[5]; vp++)	//vp < &value[5] 指针的关系运算, vp++ 指针+整数
	{
		*vp = 0;	//*vp对应的变量赋值为0
		printf("%d ", *vp);	//0 0 0 0 0 
	}

	//my_strlen - 求字符串长度
	int len = my_strlen("abc");	//传的参数为char类型的指针 指向字符串的首元素(a)的地址
	printf("\nstrlen = %d\n", len);

	int len2 = my_strlen2("abcd");
	printf("\nstrlen2 = %d\n", len2);


	return 0;
}

//利用计数器count求字符串长度
int my_strlen(char* str)
{
	int count = 0;
	while (*str != '\0')	//指针指向的元素不是'\0'时
	{
		count++;
		str++;	//指针后移到下一元素
	}
	return count;
}
//利用同一空间指针相减得到元素求字符串长度
int my_strlen2(char* str)
{
	char* start = str;
	while (*str != '\0')	//指针指向的元素不是'\0'时
	{
		str++;	//指针后移到下一元素
	}
	return str - start;	//指针相减得到两个地址之间的元素个数
}

