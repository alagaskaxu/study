#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//表达式的求值
//表达式的求值顺序一般是由操作符的优先级和结合性决定,有些表达式的操作数在求值过程中可能需要转换为其它类型

//隐式类型转换:表达式中的字符和短整形操作数在使用之前被转换为普通整形,这种转换称为整形提升,整形提升按照变量的数据类型的符号位来提升的,正数则高位补符号位0,负数高位补1,无符号数统一默认补0,表达式运算结束,进行截断,回到原来的类型
// 即:由于cpu运算器,使得小于int整形的变量类型,在进行计算时要将类型的大小扩充到4字节,(大的不用扩充)才能方便进入cpu内进行运算
//原因:cpu一次运算bit位的最小长度与运算器有关,cpu内运算器的操作数的长度一般就是int类型的大小,同时也是cpu的通用寄存器的长度;
//将小于int整形的类型提升为普通整形再运算还能提高精度

int main()
{
	char x = '0', y = '1', z = '2';	//ASCII 49  50
	x = y + z;	//char类型先提升为4字节大小(普通整形),再执行加法运算,最后结果被截断,然后存储于x中
	printf("%c\n", x);//ASCII码99,'c'
	x = 2;	//(内存中占1字节) 00000010	字符型 整形提升 为普通整形(内存中占4字节) 00000000 00000000 00000000 00000010	(方便cpu运算)
	y = 127;	//char类型8位二进制码的范围为-128~127,最高位为符号位剩下7位数据位01111111为127最大,11111111(原码)为-127(实际内存为10000001),特殊的10000000为-128,二进制加完溢出的话会从最大的数变到最小的数(补码)
	z = x + y;	//因为内存中用补码存放数据,所以01111111 + 00000011 = 10000010(-126的补码)	溢出的1直接丢弃 ,表达式运算结束则变回原来的类型,开始截断,char最后只剩低8位
	printf("%d\n", z);	//-126	此时以有符号数整形的十进制格式进行打印,也需要整形提升,z变为: 11111111 11111111 11111111 100000010(补码)->原码为10000000 00000000 00000000 11111110 == -126
	//整形提升按照变量的数据类型的符号位来提升的(无符号数高位统一补0),如:x = -1; (内存中的补码)11111111 整形提升后: 11111111 11111111 11111111 11111111 

	x = 0xb6;	//182	最高位为1
	short s = 0xb600;	//46592 最高位为1
	int a = 0xb6000000;
	if (x == 0xb6)	//整形提升后两数不相等,也可以理解为182超过了char类型的最大值,导致数值出错
	{
		printf("x = %X", x);
	}
	if (s == 0xb600)	//整形提升后两数不相等
	{
		printf("s = %X", s);
	}
	if (a == 0xb6000000)	//成立
	{
		printf("a = %X\n", a);
	}

	x = 1;
	printf("x的xsize = %u\n", sizeof(x));	//1	字符型
	printf("+x的xsize = %u\n", sizeof(+x));	//4	+x使得字符型和+运算,要整形提升为int型,虽然sizeof内的表达式不进行运算不会得结果,但是需要会将变量的类型属性进行推算
	printf("-x的xsize = %u\n", sizeof(-x));	//4 同上,不过有些编译器不同可能类似sizeof(!x)仍为1


	return 0;
}


